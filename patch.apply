diff --git a/Gemfile b/Gemfile
index 666acdd..e02c56a 100644
--- a/Gemfile
+++ b/Gemfile
@@ -5,7 +5,7 @@ git_source(:github) do |repo_name|
   "https://github.com/#{repo_name}.git"
 end
 
-ruby '2.4.0'
+# ruby '2.4.0'
 
 gem 'figaro'
 
diff --git a/Gemfile.lock b/Gemfile.lock
index 4b58faf..c6f60a5 100644
--- a/Gemfile.lock
+++ b/Gemfile.lock
@@ -261,8 +261,5 @@ DEPENDENCIES
   uglifier (>= 1.3.0)
   web-console (>= 3.3.0)
 
-RUBY VERSION
-   ruby 2.4.0p0
-
 BUNDLED WITH
    1.14.6
diff --git a/app/models/king.rb b/app/models/king.rb
index e886233..1eb17d5 100644
--- a/app/models/king.rb
+++ b/app/models/king.rb
@@ -3,105 +3,82 @@ class King < Piece
 
 =begin  def valid_move?(x, y)
       super(x, y)
-      
-      move_range = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]]  
+
+      move_range = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]]
       move_coordinates = []
-      
+
       move_range.each do |dx, dy|
         if within_chessboard?(x_position + dx, y_position + dy)
           move_coordinates << [(x_position + dx), (y_position + dy)]
         end
       end
-     
-     return move_coordinates.include?([x,y])  
-    end 
-=end 
+
+     return move_coordinates.include?([x,y])
+    end
+=end
 
   def valid_move?(x, y)
-    super(x, y)
-    return true if king_move(x, y) 
-    if can_castle?(x, y)
-      castle!
-      return true 
-    end 
-    false
-  end 
+    super(x, y) && (valid_king_move?(x, y) || can_castle?(x, y))
+  end
 
-  def king_move(x, y)
+  def valid_king_move?(x, y)
     dx = (x - x_position).abs
     dy = (y - y_position).abs
-    dx <= 1 && dy <= 1
-  end 
-  
+    dx <= 1 && dy <= 1 && dx + dy > 0
+  end
+
 
   def checkmate?
     # example logic
   end
 
-  def castle_rook(side)
-    case side
-    when 'Kingside'
-      game.pieces.find_by(
-        piece_type: 'Rook',
-        x_position: 7,
-        y_position: y_position)
-    when 'Queenside'
-      game.pieces.find_by(
-        piece_type: 'Rook',
-        x_position: 0,
-        y_position: y_position)
-    else 
-      return nil 
-    end 
-  end 
+  def castle_rook(x)
+    @castle_rook ||= game.pieces.find_by(
+      piece_type: 'Rook',
+      x_position: (x > x_position ? 7 : 0),
+      y_position: y_position
+    )
+  end
 
   def can_castle?(x, y)
-    #rtn false if in check
-    return false unless state == 'unmoved'
-    if x > x_position
-      @rook = castle_rook('Kingside')
-      @new_king_x = 6
-      @new_rook_x = 5 
-    else 
-      @rook = castle_rook('Queenside')
-      @new_rook_x = 3 
-      @new_king_x = 2 
-    end 
-
-    return false if castle_rook.nil? 
-    return false unless castle_rook.state == 'unmoved'
-    true 
-  end 
+    # king and rook are unmoved
+    # both needs to change position
+    # no pieces bw the rook and the king
+    state == 'unmoved' &&
+      !castle_rook(x).nil? &&
+      castle_rook(x).state == 'unmoved' &&
+      horizontal_obstruction(x, y)
+  end
 
-  def castle! 
+  def castle!
     update_attributes(@new_king_x, y_position)
     @rook.update_attributes(@new_rook_x, y_position)
-  end 
-end 
+  end
+end
 =begin
   def castle!(rook)
     return false unless can_castle?(rook)
     if queenside?(rook)
       update_attributes(x_position: 2, state: 'moved')
       rook.update_attributes(x_position: 3, state: 'moved')
-      return true 
+      return true
     else #kingside
       update_attributes(x_position: 6, state: 'moved')
       rook.update_attributes(x_position: 5, state: 'moved')
-      return true 
-    end 
-  end 
+      return true
+    end
+  end
 
   def can_castle?(rook)
     #to do: return false if in check
-    #to do: return false if spaces between rook & king are obstructed 
+    #to do: return false if spaces between rook & king are obstructed
     return false if piece.is_obstructed?(rook.x_position, rook.y_position)
     return false unless state == 'unmoved' #ensure king hasn't moved yet
-    return false unless rook.state == 'unmoved' 
-    true 
-  end 
+    return false unless rook.state == 'unmoved'
+    true
+  end
 
   def queenside?(rook)
-    rook.x_position < x_position 
-  end 
+    rook.x_position < x_position
+  end
 =end
diff --git a/app/models/piece.rb b/app/models/piece.rb
index 754b015..11c371f 100644
--- a/app/models/piece.rb
+++ b/app/models/piece.rb
@@ -23,7 +23,7 @@ class Piece < ApplicationRecord
   end
 
   def valid_move?(x, y)
-    return false if !within_chessboard?(x, y)
+    within_chessboard?(x, y)
   end
 
   def self.piece_types
diff --git a/config/database.yml b/config/database.yml
index d0a6672..f0557e2 100644
--- a/config/database.yml
+++ b/config/database.yml
@@ -21,8 +21,8 @@ default: &default
   # http://guides.rubyonrails.org/configuring.html#database-pooling
   pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
   username: postgres
-  password: password
-  host: localhost
+  password: 
+  host: 192.168.99.100
 
 development:
   <<: *default
diff --git a/spec/models/king_spec.rb b/spec/models/king_spec.rb
index e6883d2..27fa432 100644
--- a/spec/models/king_spec.rb
+++ b/spec/models/king_spec.rb
@@ -1,39 +1,47 @@
 require 'rails_helper'
 
 RSpec.describe King, type: :model do
+  let(:game) do
+    Game.create(
+      white_user: FactoryGirl.create(:user),
+      black_user: FactoryGirl.create(:user)
+    )
+  end
 
   describe 'valid_move?' do
-      
-    king = King.create(color: true, x_position: 3, y_position: 5)
-    
+
+    let(:king) do
+      King.create(color: true, x_position: 3, y_position: 5, game: game)
+    end
+
     it 'be a valid move' do
       expect(king.valid_move?(3, 6)).to eq(true)
       expect(king.valid_move?(3, 4)).to eq(true)
       expect(king.valid_move?(2, 6)).to eq(true)
       expect(king.valid_move?(2, 5)).to eq(true)
       expect(king.valid_move?(2, 4)).to eq(true)
-      expect(king.valid_move?(4, 6)).to eq(true)  
+      expect(king.valid_move?(4, 6)).to eq(true)
       expect(king.valid_move?(4, 5)).to eq(true)
-      expect(king.valid_move?(4, 4)).to eq(true)    
+      expect(king.valid_move?(4, 4)).to eq(true)
     end
 
-    it 'be an invalid move' do
+    it 'be an invalid move', focus: true do
       expect(king.valid_move?(3, 5)).to eq(false)
       expect(king.valid_move?(3, 7)).to eq(false)
       expect(king.valid_move?(3, 8)).to eq(false)
       expect(king.valid_move?(1, 5)).to eq(false)
     end
   end
-  
+
   describe 'castling' do
-    
-    context 'valid castle moves' do 
+
+    context 'valid castle moves' do
       it 'returns true for castling' do
-        king = King.create(color: true, x_position: 4, y_position: 0, state: 'unmoved')
-        rook = Rook.create(color: true, x_position: 0, y_position: 0, state: 'unmoved')
+        king = King.create(color: true, x_position: 4, y_position: 0, state: 'unmoved', game: game)
+        rook = Rook.create(color: true, x_position: 0, y_position: 0, state: 'unmoved', game: game)
         expect(king.can_castle?(2, 0)).to eq(true)
-      end 
-    end 
-  end 
+      end
+    end
+  end
 
-end
\ No newline at end of file
+end
