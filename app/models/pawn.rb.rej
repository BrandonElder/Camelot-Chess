diff a/app/models/pawn.rb b/app/models/pawn.rb	(rejected hunks)
@@ -1,4 +1,5 @@
 class Pawn < Piece
+
   def valid_move?(x, y)
     if super(x, y)
       if is_capture?(x, y)
@@ -13,26 +14,50 @@ class Pawn < Piece
     end
     false
   end
-# EN PASSANT 
+# EN PASSANT
+
+  def update_en_passant_posistion(x,y)
+    return unless in_starting_position?
+    dy = y_position - y
+    update_attributes en_passant_x: x_position, en_passant_y: (y_position  - dy/2)
+  end
+
+  def move_to!(x, y)
+    return unless color == game.user_turn
+    update_en_passant_posistion(x,y)
+    capture_passant(x,y) if valid_en_passant?(x, y)
+    super
+  end
+
+  #
+  # g = Game.new
+  # g.white_user = User.first
+  # g.black_user = User.second
+  # g.save
+  #
+  # q = g.pieces.where(color: 'BLACK', piece_type: 'Pawn').first.update_attributes(x_position: 1, y_position: 3)
+  # p = g.pieces.where(color: 'WHITE', piece_type: 'Pawn').first
+  # p.move_to!(0,3)
+  # q.move_to!(0,2)
+
+
+  def valid_en_passant?(x, y)
+    last_piece = game.pieces.order(:updated_at).last
+    last_piece.piece_type == 'Pawn' && last_piece.en_passant_y &&
+    last_piece.en_passant_y == y && last_piece.en_passant_x == x_position
+  end
 
-  def valid_en_passant?(x, y, direction)
-    return false if game.en_passant == false 
-    return false if last_piece_moved.nil?
-    return true if x == last_piece_moved.x_position && 
-                   y == last_piece_moved.y_position + direction
-    false 
-  end 
+  def capture_passant(x,y)
+    last_piece = game.pieces.order(:updated_at).last
+    capture_piece_at(last_piece.x_position, last_piece.y_position)
+  end
 
   def last_piece_moved
     game.pieces.where(last_moved: (game.move_number - 1)).take
-  end 
+  end
 
   def in_starting_position?
-    if (color == 'WHITE' && y_position == 1) || (color == 'BLACK' && y_position == 6)
-      true
-    else
-      false
-    end
+    (color == 'WHITE' && y_position == 1) || (color == 'BLACK' && y_position == 6)
   end
 
   def one_square?(x, y)
